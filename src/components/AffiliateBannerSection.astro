---
/**
 * AffiliateBannerSection Component
 *
 * Displays affiliate banners in two modes:
 * - "all": Shows all enabled banners in a responsive masonry grid (homepage)
 * - "single": Shows only the banner for a specific service (service pages)
 *
 * If no banners are available, the section is not rendered.
 */

import AffiliateBanner from './ui/AffiliateBanner.astro';
import { getAffiliateBanners } from '../lib/sanity';
import type { SupportedLanguage } from '../i18n/config';
import { t } from '../i18n/translations';

export interface Props {
  variant: 'all' | 'single';
  serviceId?: string;
  title?: string;
  lang?: SupportedLanguage;
}

const {
  variant = 'all',
  serviceId,
  title,
  lang = 'en' as SupportedLanguage
} = Astro.props;

const sectionTitle = title || t(lang, 'affiliate.partnersTitle');
const subtitle = t(lang, 'affiliate.partnersSubtitle');
const disclosure = t(lang, 'affiliate.disclosure');
const learnMoreText = t(lang, 'affiliate.learnMore');

// Fetch banners based on variant - NOW WITH LOCALE FILTERING
const banners = await getAffiliateBanners(
  variant === 'single' ? serviceId : undefined,
  lang  // FIXED: Pass locale to filter banners by language
);

// Don't render if no banners available
if (banners.length === 0) {
  return null;
}
---

{banners.length > 0 && (
  <section
    class="affiliate-banner-section py-12 bg-gray-50"
    aria-label="Affiliate Partners"
  >
    <div class="container mx-auto px-4">
      <div class="max-w-7xl mx-auto">
        {variant === 'all' && (
          <>
            <div class="text-center mb-8">
              <h2 class="text-2xl lg:text-3xl font-bold text-gray-900 mb-2">
                {sectionTitle}
              </h2>
              <p class="text-gray-600">
                {subtitle}
              </p>
            </div>

            <div class="masonry-grid" id="affiliate-masonry-grid">
              <!-- Masonry columns -->
              <div class="masonry-col"></div>
              <div class="masonry-col hidden md:block"></div>
              <div class="masonry-col hidden lg:block"></div>

              <!-- Masonry items (client-side script will sort and distribute by height) -->
              {banners.map((banner) => (
                <AffiliateBanner
                  serviceId={banner.serviceId}
                  htmlCode={banner.htmlCode}
                  description={banner.description}
                  class="masonry-item"
                />
              ))}
            </div>
          </>
        )}

        {variant === 'single' && (
          <div class="max-w-3xl mx-auto">
            {banners.map((banner) => (
              <AffiliateBanner
                serviceId={banner.serviceId}
                htmlCode={banner.htmlCode}
                description={banner.description}
              />
            ))}
          </div>
        )}

        {variant === 'all' && (
          <div class="text-center mt-6">
            <p class="text-sm text-gray-500">
              {disclosure}{' '}
              <a href={`/${lang}/about`} class="text-green-600 hover:text-green-700 underline">
                {learnMoreText}
              </a>
            </p>
          </div>
        )}
      </div>
    </div>
  </section>
)}

<style>
  .affiliate-banner-section {
    /* Additional styling if needed */
  }

  /* Masonry grid layout */
  .masonry-grid {
    display: flex;
    gap: 1.5rem;
  }

  /* Masonry columns - responsive widths */
  .masonry-col {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
  }

  /* Hide grid initially while measuring */
  .masonry-grid {
    visibility: hidden;
  }

  .masonry-grid.ready {
    visibility: visible;
  }

  /* Hide items initially to prevent FOUC */
  .masonry-item {
    opacity: 0;
    transition: opacity 0.3s ease-in;
  }

  .masonry-item.loaded {
    opacity: 1;
  }

  /* Single column on mobile */
  @media (max-width: 767px) {
    .masonry-grid {
      flex-direction: column;
    }
  }
</style>

<script>
  async function initMasonry() {
    console.log('ðŸ”§ Initializing optimized masonry grid with bin-packing algorithm...');
    const grid = document.querySelector('#affiliate-masonry-grid');

    if (!grid) {
      console.error('âŒ Masonry grid element not found');
      return;
    }

    const items = Array.from(grid.querySelectorAll('.masonry-item'));
    const columns = Array.from(grid.querySelectorAll('.masonry-col'));

    console.log('ðŸ“Š Items found:', items.length);
    console.log('ðŸ“Š Columns found:', columns.length);

    if (columns.length === 0) {
      console.error('âŒ No columns found');
      return;
    }

    // Wait for all images to load before measuring heights
    await waitForImagesToLoad(grid);
    console.log('âœ… All images loaded');

    // Temporarily place all items in first column to measure their natural heights
    items.forEach(item => {
      columns[0].appendChild(item);
    });

    // Wait for layout to settle
    await new Promise(resolve => requestAnimationFrame(() => requestAnimationFrame(resolve)));

    // Measure actual heights of each item NOW (after proper layout)
    const itemsWithHeights = items.map((item, index) => ({
      element: item,
      height: item.offsetHeight,
      index
    }));

    // Log measured heights
    console.log('ðŸ“ Measured heights:', itemsWithHeights.map(item =>
      `Banner ${item.index}: ${item.height}px`
    ));

    // Sort by height descending (tallest first) - Best Fit Decreasing
    itemsWithHeights.sort((a, b) => b.height - a.height);

    console.log('ðŸ”„ Sorted by height (tallest first):',
      itemsWithHeights.map(item => `${item.height}px`).join(', ')
    );

    // Initialize column tracking
    const columnHeights = columns.map(() => 0);
    const columnItems = columns.map(() => []);

    // Distribute items using Best Fit Decreasing algorithm
    itemsWithHeights.forEach(item => {
      // Find column with minimum current height
      const minHeight = Math.min(...columnHeights);
      const targetColumnIndex = columnHeights.indexOf(minHeight);

      // Assign item to that column
      columnItems[targetColumnIndex].push(item);
      columnHeights[targetColumnIndex] += item.height;
    });

    // Log distribution
    console.log('ðŸ“Š Column distribution:');
    columnHeights.forEach((height, index) => {
      console.log(`  Column ${index + 1}: ${height}px (${columnItems[index].length} items)`);
    });

    const maxHeight = Math.max(...columnHeights);
    const minHeight = Math.min(...columnHeights);
    const difference = maxHeight - minHeight;
    console.log(`âš–ï¸  Height difference: ${difference}px (${((difference/maxHeight)*100).toFixed(1)}%)`);

    // Clear all columns
    columns.forEach(col => col.innerHTML = '');

    // Place items in their assigned columns
    columnItems.forEach((items, columnIndex) => {
      items.forEach(item => {
        columns[columnIndex].appendChild(item.element);
      });
    });

    console.log('âœ… Items distributed with optimal bin-packing');

    // Show grid
    grid.classList.add('ready');

    // Show items with fade-in effect
    setTimeout(() => {
      items.forEach(item => {
        item.classList.add('loaded');
      });
      console.log('âœ… Items shown with fade-in');
    }, 50);
  }

  // Wait for all images within a container to load
  function waitForImagesToLoad(container) {
    const images = Array.from(container.querySelectorAll('img'));

    if (images.length === 0) {
      return Promise.resolve();
    }

    const promises = images.map(img => {
      if (img.complete) {
        return Promise.resolve();
      }
      return new Promise((resolve) => {
        img.addEventListener('load', resolve);
        img.addEventListener('error', resolve); // Resolve even on error to not block
        // Timeout after 5 seconds to prevent infinite waiting
        setTimeout(resolve, 5000);
      });
    });

    return Promise.all(promises);
  }

  // Try multiple events to ensure it runs
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initMasonry);
  } else {
    // DOM already loaded
    initMasonry();
  }

  // Also listen for Astro page loads (for SPA navigation)
  document.addEventListener('astro:page-load', initMasonry);
</script>
